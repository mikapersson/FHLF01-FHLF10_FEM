% SOLUTION FOR THE PROJECT IN FEM 2020

%% PREPROCESSOR
clear
clc

mesh = load('mesh.mat');  % geometry/mesh of half the IC
p = mesh.p;  % points/nodes (x:y for each column)
e = mesh.e;  % edges  (rows 1,2: node # of el. seg., 5: edge label bd. seg.)
t = mesh.t;  % triangles (4xnelm, rows 1-3: node numbers, 4: subdomain)

% DONT FORGET TO CONVERT FROM mm TO m!!

% Constants
domain_k = [385; 149; 5; 385];  % k for each domain domain (domains are given in the geometry)
thickness = 10;                 % thickness of the IC
initTemp = 30;                  % initial temperature
envTemp = 18;                   % environment temperature
alpha_c = 40;                   % convection parameter ??????????????????????????????
Q = 5*10^7;                     % heat generated by the die
domain_Q = [0;Q;0;0];           % Q in the four domains

% Material constants
E_Ag = 7;
E_Si = 165;
E_Cu = 128;
nu_Ag = 0.3;
nu_Si = 0.22;
nu_Cu = 0.36;
alpha_Ag = 4*10^-5;
alpha_Si = 2.6*10^-6;
alpha_Cu = 17.6*10^-6;
rho_Ag = 2500;
rho_Cu = 2530;
rho_Cu = 8930;
c_Ag = 1000;
c_Si = 703;
c_Cu = 386;
k_Ag = 5;
k_Si = 149;
k_Cu = 385;

% Calculate edof matrices
coord = p';
enod=t(1:3,:)';                     % nodes of elements
nelm=size(enod,1);                  % number of elements
nnod=size(coord,1);                 % number of nodes
dof=(1:nnod)';                      % dof number is node number
dof_S=[(1:nnod)',(nnod+1:2*nnod)']; % give each dof a number

for ie=1:nelm
    edof_S(ie,:)=[ie dof_S(enod(ie,1),:), dof_S(enod(ie,2),:),dof_S(enod(ie,3),:)];
    edof(ie,:)=[ie,enod(ie,:)];
end

[ex,ey]=coordxtr(edof,coord,dof,3);  % x- and y coordinates for each node

% Check which segments that should have convections
er = e([1 2 5],:);        % reduced e (only interested of rows 1, 2 and 5)
conv_segments = [1 9 18]; % choosen boundary segments
edges_conv = [];          % edges with convection

for i = 1:size(er,2)
    if ismember(er(3,i),conv_segments)
        edges_conv = [edges_conv er(1:2,i)];  % may use preallocation
    end
end

nodes_conv = unique(edges_conv);             % nodes that belong to the convection boundary
nr_conv_nodes = size(nodes_conv, 1);         % number of nodes on the convection boundary
nodes_conv_coord = zeros(nr_conv_nodes, 2);  % x- & y-coordinate for every node on the convection boundary

% Fill nodes_conv_coord-matrix
for node_nr = 1:nr_conv_nodes
    node = nodes_conv(node_nr);  % index for current node on convection boundary
    
    x_coord = coord(node,1);     % get x-coord of currect conv. node
    y_coord = coord(node,2);     % get y-coord..
    
    nodes_conv_coord(node_nr,:) = [x_coord, y_coord];
end

%% SOLVER
ndof = nnod;       % number degrees of freedom (x & y per node)
D = eye(2);          % 2D constitutive element matrix
K = zeros(ndof);     % stiffness matrix
f = zeros(ndof, 1);  % force vector 

for elnr = 1:nelm
    
    subdomain = t(4,elnr);
    temp_k = domain_k(subdomain);
    temp_Q = domain_Q(subdomain);
    temp_D = temp_k * D;
    
    [Ke, fe] = flw2te(ex(elnr,:), ey(elnr,:), thickness, temp_D, temp_Q);
    indx = edof(elnr,2:end);       
    K(indx,indx) = K(indx,indx)+Ke; 
    
    indx = edof(elnr,2:end);               
    f(indx) = f(indx) + fe;             
end

init_temp = zeros(nr_conv_nodes, 1);        % initial temperature on conv. bound.

bc = [nodes_conv, init_temp];

T = solveq(K, f, bc);  % nodal temperatures

%% POST PROCESSOR
eT=extract(edof,T);   % element temperatures

% In order to plot both sides of the symmetry cut:
patch(ex',ey',eT');   %
hold on     
patch(-ex',ey',eT');  % 

title('Temperature distribution [C]')
colormap(jet);
colorbar;
xlabel('x-position [m]')
ylabel('y-position [m]')
axis equal



