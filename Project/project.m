% SOLUTION FOR THE PROJECT IN FEM 2020

%% PREPROCESSOR
clear
clc

mesh = load('mesh_fine2.mat');  % geometry/mesh of half the IC
p = mesh.p;  % points/nodes (x:y for each column)
e = mesh.e;  % edges  (rows 1,2: node # of el. seg., 5: edge label bd. seg.)
t = mesh.t;  % triangles (4xnelm, rows 1-3: node numbers, 4: subdomain)

% DONT FORGET TO CONVERT FROM mm TO m!!

% Constants
domain_k = [385; 149; 5; 385];  % k for each domain domain (domains are given in the geometry)
thickness = 10;                 % thickness of the IC
initTemp = 30;                  % initial temperature
envTemp = 18;                   % environment temperature
alpha_c = 40;                   % convection parameter ??????????????????????????????
Q = 5*10^7;                     % heat generated by the die
domain_Q = [0;Q;0;0];           % Q in the four domains (domains are given in the geometry)

% Material constants
E_Ag = 7;
E_Si = 165;
E_Cu = 128;
nu_Ag = 0.3;
nu_Si = 0.22;
nu_Cu = 0.36;
alpha_Ag = 4*10^-5;
alpha_Si = 2.6*10^-6;
alpha_Cu = 17.6*10^-6;
rho_Ag = 2500;
rho_Cu = 2530;
rho_Cu = 8930;
c_Ag = 1000;
c_Si = 703;
c_Cu = 386;
k_Ag = 5;
k_Si = 149;
k_Cu = 385;

% Calculate edof matrices
coord = p';
coord = coord*10^-3;
enod=t(1:3,:)';                     % nodes of elements
nelm=size(enod,1);                  % number of elements
nnod=size(coord,1);                 % number of nodes
dof=(1:nnod)';                      % dof number is node number
dof_S=[(1:nnod)',(nnod+1:2*nnod)']; % give each dof a number

for ie=1:nelm
    edof_S(ie,:)=[ie dof_S(enod(ie,1),:), dof_S(enod(ie,2),:),dof_S(enod(ie,3),:)];
    edof(ie,:)=[ie,enod(ie,:)];
end

[ex,ey]=coordxtr(edof,coord,dof,3);  % x- and y coordinates for each node

% Check which segments that should have convections
er = e([1 2 5],:);        % reduced e (only interested of rows 1, 2 and 5)
conv_segments = [1 9 18]; % choosen boundary segments
edges_conv = [];          % edges with convection

for i = 1:size(er,2)
    if ismember(er(3,i),conv_segments)
        edges_conv = [edges_conv er(1:2,i)];  % may use preallocation
    end
end

nr_conv_edges = size(edges_conv,2);
nodes_conv = unique(edges_conv);             % nodes that belong to the convection boundary
nr_conv_nodes = size(nodes_conv, 1);         % number of nodes on the convection boundary
edges_conv_coord = zeros(nr_conv_nodes, 4);  % (x,y)-coordinate for the two nodes
                                             % for every edge represented
                                             % as [x1, x2, y1, y2]
% Fill nodes_conv_coord-matrix
for edge_nr = 1:nr_conv_edges
    edges_conv_coord(1,edge_nr) = coord(edges_conv(1,edge_nr),1);  %x1
    edges_conv_coord(2,edge_nr) = coord(edges_conv(2,edge_nr),1);  %x2
    edges_conv_coord(3,edge_nr) = coord(edges_conv(1,edge_nr),2);  %y1
    edges_conv_coord(4,edge_nr) = coord(edges_conv(2,edge_nr),2);  %y2
end

%% SOLVER
ndof = nnod;       % number degrees of freedom (x & y per node)
D = eye(2);          % 2D constitutive element matrix
K = zeros(ndof);     % stiffness matrix
f = zeros(ndof, 1);  % force vector 

% Create the stiffness matrix (K) and force vector (f)
for elnr = 1:nelm
    
    subdomain = t(4,elnr);         % what subdomain the current element belongs to
    temp_k = domain_k(subdomain);  % current k-value
    temp_Q = domain_Q(subdomain);  % current Q-value
    temp_D = temp_k*D;           % current D-matrix
    
    % Get element stiffness matrix and force vector
    [Ke, fe] = flw2te(ex(elnr,:), ey(elnr,:), thickness, temp_D, temp_Q);
    
    if subdomain == 3  % only subdomain 3 has convection
        % Examine if the current element (elnr) has any boundaries with
        % convection, if so we shall modify Ke
        for i = 1:size(edges_conv,2)
            if ismember([edges_conv(1,i), edges_conv(2,i)],enod(elnr,:))
                 x1 = edges_conv_coord(1,i);
                 x2 = edges_conv_coord(2,i);
                 y1 = edges_conv_coord(3,i);
                 y2 = edges_conv_coord(4,i);
                 boundaryLength = sqrt((x2-x1)^2+(y2-y1)^2);
                 a = thickness*alpha_c*[0, 0, 0; 0, boundaryLength/3, boundaryLength/6; 0, boundaryLength/6, boundaryLength/3];
                 Ke = Ke+a;
                 fe = fe+thickness*alpha_c*envTemp*[0; boundaryLength/2; boundaryLength/2];
            end
        end
        
    end
    indx = edof(elnr,2:end);       
    K(indx,indx) = K(indx,indx)+Ke;              
    f(indx) = f(indx) + fe;     
end

%init_temp = zeros(nr_conv_nodes, 1);        % initial temperature on conv. bound.

%bc = [nodes_conv, init_temp];

T = solveq(K, f);  % nodal temperatures

%% POST PROCESSOR
eT=extract(edof,T);   % element temperatures

% In order to plot both sides of the symmetry cut:
patch(ex',ey',eT');   %
hold on     
patch(-ex',ey',eT');  % 

title('Temperature distribution [C]')
colormap(hot);
colorbar;
xlabel('x-position [m]')
ylabel('y-position [m]')
axis equal



